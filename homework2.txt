ECE 574 - Cluster Computing
Homework #2
Name: Derek Haas
Date: 2-5-19
Account Username: ece574-6


2. 

a) OMP_NUM_THREADS = 1
   Time: 118.36s
   Gflops: 45.07

   OMP_NUM_THREADS = 2
   Time: 61.81s
   Gflops: 86.29

   OMP_NUM_THREADS = 4
   Time: 34.69s
   Gflops: 153.7

   OMP_NUM_THREADS = 8
   Time: 20.2s
   Gflops: 264

b)

   i) 
	P = 2, Ts = 118.36, Tp = 61.81
        Sp = Ts / Tp = (118.36 / 61.81) = 1.91

        P = 4, Ts = 118.36, Tp = 34.69
        Sp = Ts / Tp = (118.36 / 34.69) = 3.41

        P = 8, Ts = 118.36, Tp = 20.2
        Sp = Ts / Tp = (118.36 / 20.2) = 5.86

   ii)
	P = 2, Sp = 1.91
	Ep = Sp / P = (1.91 / 2) = 0.995

	P = 4, Sp = 3.41
	Ep = Sp / P = (3.41 / 4) = 0.8525

	P = 8, Sp = 5.86
	Ep = Sp / P = (5.86 / 8) = 0.7325

   iii)
	When more threads were used, the parallel efficency decreased.
	This means that instead of parallel efficency following a
	"linear" speedup, the parallel efficency would decrease as
	more threads are used.  An ideal speedup would be Sp = P,
	as more threads would cut the run time in half.  If the
	speedup doesnt match the number of threads, the parallel
	efficency is poor.

	This benchmark does NOT show strong scaling, as when more
	threads are used, the parallel efficency decreases.

   iv)
	
	The gathered results appear to show that the benchmark exhibits
	weak scaling.  As more threads are used, the time to complete
	Linpack decreases, yet the parallel efficency continues to
	decrease, and the speedup value continues to grow further away
	away from the value of threads used.  However, more data 
	(more tests with the same threads) should be done to verify this.

   v)

	The real time is a higher value than the value given by the HPL.
	This is because real time is "clock time" meaning it is the time
	from when the user presses "Enter" to run the program, to when
	the program ends.  The HPL time is the time it took for the matrix
	multiply.  Also, the Haswell runs Linux and may have some over head
	thats gets built into the real time because of context switching.

   vi)

	The User time is much much larger than the real time.  This is
	because the program is using multiple threads.  If 1s passes in
	real time during the program, and the program uses 8 threads, the 
	User time is then 8s.  User time will increase as threads increase.

3. 

a)

	dgemm_kernel accounts for 52.53% of the total run time, making it 
	the function that takes up the most time.
	
b)

	The assembly instruction "vmovups (%r15), %ymm3" takes up the most time
	at 0.97% of the program.	

c)	

	Skid is the effect that may cause an instruction to not be the real
	instruction taking up the most time.  A earlier instruction may
	be causing all the time, cause the program to "skid" to a halt at
	a later instruction.
